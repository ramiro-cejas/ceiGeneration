.CODE
PUSH Method_main@Init # We put main method's tag at the top of the stack
CALL # We jump to main method
HALT # End of program.
malloc: LOADFP
LOADSP
STOREFP
LOADHL
DUP
PUSH 1
ADD
STORE 4
LOAD 3
ADD
STOREHL
STOREFP
RET 1
.DATA
str_empty: DW 0
.DATA
VT@Init: NOP # This class doesnt have any dynamic methods
.DATA
Attribute_animal@Init: DW 0

.CODE
Method_main@Init: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
RMEM 2 # Reserving space for block local vars
PUSH 0
STORE 0 # We store what's on top of the pile in the stack through localvar's offset
PUSH 0
STORE -1 # We store what's on top of the pile in the stack through localvar's offset
while_5: NOP
LOAD 0 # We get the variable i is 2 from the stack through its offset
PUSH 3
LT
BF end_while_5
RMEM 2 # Reserving space for block local vars
LOAD 0 # We get the variable i is 2 from the stack through its offset
PUSH 0
EQ
BF else_if_6
RMEM 2 # Reserving space for block local vars
RMEM 1 # We reserve a memory cell to store the pointer to the constructed object
PUSH 1 # We load malloc's parameter: the number of cells to reserve for the constructed object
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@Cat # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH Constructor@Cat # We put the constructor's tag on top of the stack
CALL # We make the call
DUP # duplicating the value to be assigned
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
SWAP # We swap the tag and what we desire to write into the attribute
STOREREF 0 # We write into the data through the tag
POP # Discarding not used return value
FMEM 2 # Freeing space reserved for block local vars
JUMP out_if_6
else_if_6: NOP
LOAD 0 # We get the variable i is 2 from the stack through its offset
PUSH 1
EQ
BF else_if_7
RMEM 2 # Reserving space for block local vars
RMEM 1 # We reserve a memory cell to store the pointer to the constructed object
PUSH 1 # We load malloc's parameter: the number of cells to reserve for the constructed object
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@Dog # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH Constructor@Dog # We put the constructor's tag on top of the stack
CALL # We make the call
DUP # duplicating the value to be assigned
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
SWAP # We swap the tag and what we desire to write into the attribute
STOREREF 0 # We write into the data through the tag
POP # Discarding not used return value
FMEM 2 # Freeing space reserved for block local vars
JUMP out_if_7
else_if_7: NOP
RMEM 2 # Reserving space for block local vars
RMEM 1 # We reserve a memory cell to store the pointer to the constructed object
PUSH 1 # We load malloc's parameter: the number of cells to reserve for the constructed object
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@Cow # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH Constructor@Cow # We put the constructor's tag on top of the stack
CALL # We make the call
DUP # duplicating the value to be assigned
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
SWAP # We swap the tag and what we desire to write into the attribute
STOREREF 0 # We write into the data through the tag
POP # Discarding not used return value
FMEM 2 # Freeing space reserved for block local vars
out_if_7: NOP
out_if_6: NOP
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
LOADREF 0 # We read the attributes value from the data using the tag
RMEM 1 # We reserve a memory cell for the method's return value
SWAP  # We swap to keep the 'this' reference at the top of the stack
DUP # We duplicate the 'this' reference so we don't lose it when it's used by LOADREF
LOADREF 0 # We load the VTable (VTable offset is always 0)
LOADREF 2 # We load the method's address through the VTable.
CALL # We make the call.
DUP # duplicating the value to be assigned
STORE -1 # We write into the variable in the stack, through its offset
POP # Discarding not used return value
LOAD -1 # We get the variable id is 2 from the stack through its offset
PUSH Method_printI@System # We push the static method's tag to the top of the stack
CALL # We make the call.
.DATA
str_7: DW ": ",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_7 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
PUSH Method_printS@System # We push the static method's tag to the top of the stack
CALL # We make the call.
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
LOADREF 0 # We read the attributes value from the data using the tag
RMEM 1 # We reserve a memory cell for the method's return value
SWAP  # We swap to keep the 'this' reference at the top of the stack
DUP # We duplicate the 'this' reference so we don't lose it when it's used by LOADREF
LOADREF 0 # We load the VTable (VTable offset is always 0)
LOADREF 1 # We load the method's address through the VTable.
CALL # We make the call.
PUSH Method_printSln@System # We push the static method's tag to the top of the stack
CALL # We make the call.
PUSH Attribute_animal@Init # We put the static attribute's tag at the top of the stack
LOADREF 0 # We read the attributes value from the data using the tag
DUP # We duplicate the 'this' reference so we don't lose it when it's used by LOADREF
LOADREF 0 # We load the VTable (VTable offset is always 0)
LOADREF 0 # We load the method's address through the VTable.
CALL # We make the call.
LOAD 0 # We get the variable i is 2 from the stack through its offset
PUSH 1
ADD
DUP # duplicating the value to be assigned
STORE 0 # We write into the variable in the stack, through its offset
POP # Discarding not used return value
FMEM 2 # Freeing space reserved for block local vars
JUMP while_5
end_while_5: NOP
FMEM 2 # Freeing space reserved for block local vars
STOREFP # We point FP to caller's AR
RET 0 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@Init: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@Cat: DW Method_play@Cat,Method_sound@Cat,Method_id@Cat,Method_playWithYarn@Cat
.CODE

.CODE
Method_play@Cat: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # Ref to 'this'
DUP # We duplicate the 'this' reference so we don't lose it when it's used by LOADREF
LOADREF 0 # We load the VTable (VTable offset is always 0)
LOADREF 3 # We load the method's address through the VTable.
CALL # We make the call.
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_playWithYarn@Cat: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
.DATA
str_8: DW "yarn",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_8 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
PUSH Method_printSln@System # We push the static method's tag to the top of the stack
CALL # We make the call.
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_sound@Cat: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
.DATA
str_9: DW "meow",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_9 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_id@Cat: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
PUSH 0
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@Cat: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@Object: NOP # This class doesnt have any dynamic methods

.CODE
Method_debugPrint@Object: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
IPRINT # We print the integer we just loaded
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@Object: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@Cow: DW Method_play@Cow,Method_sound@Cow,Method_id@Cow,Method_waveTail@Cow,Method_eatGrass@Cow
.CODE

.CODE
Method_play@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
PUSH 99
PUSH Method_printCln@System # We push the static method's tag to the top of the stack
CALL # We make the call.
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_waveTail@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_sound@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
.DATA
str_10: DW "moo",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_10 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_id@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
PUSH 2
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_eatGrass@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@Cow: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@String: NOP # This class doesnt have any dynamic methods

.CODE
Constructor@String: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3
PUSH str_empty # We put the empty String tag at the top of the stack
STOREREF 1 # We link the 'fake attribute' to the empty string tag (attribute is hardcoded)
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@Dog: DW Method_play@Dog,Method_sound@Dog,Method_id@Dog,Method_runAfterMailman@Dog,Method_nap@Dog
.CODE

.CODE
Method_play@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
.DATA
str_11: DW "bone toy!",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_11 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
PUSH Method_printSln@System # We push the static method's tag to the top of the stack
CALL # We make the call.
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_runAfterMailman@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_sound@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
.DATA
str_12: DW "woof",0
.CODE
RMEM 1 # In String Literal: We reserve a memory cell to store the pointer to the constructed object
PUSH 2 # In String Literal: We load malloc's parameter (hardcoded)
PUSH malloc # We put malloc's tag on top of the stack
CALL # We make the call
DUP # We duplicate malloc's return so we don't lose it on our next instr.
PUSH VT@String # We push the VTable's tag so we can link it to the CIR.
STOREREF 0 # We store the reference (tag) to the VTable in the CIR of the constructed object (the offset is hard-coded)
DUP # We duplicate malloc's return and we use it as the 'this' reference for the constructor
PUSH str_12 # We put the String tag at the top of the stack
STOREREF 1 # We link the tag to the 'fake attribute'
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_id@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
PUSH 1
STORE 4 # We save the return value in the space reserved for it
STOREFP # On return: We point FP to caller's AR
RET 1 # On return: We free up memory cells equal to number of params [+1 if unit is dynamic]
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_nap@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@Dog: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
.DATA
VT@System: NOP # This class doesnt have any dynamic methods

.CODE
Method_printC@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
CPRINT # We print the char we just loaded
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printS@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
LOADREF 1 # We load the 'fake attribute' through the this reference and the offset (hardcoded)
SPRINT # We print the string we just loaded
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_println@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 0 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printCln@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
CPRINT # We print the char we just loaded
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printSln@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
LOADREF 1 # We load the 'fake attribute' of string that has the pointer to data
SPRINT # We print the String we just loaded
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_read@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
READ # We read the next integer value on the input stream.
PUSH 48 # We push 48 because the integer 0 is represented by the char number 48 in the ASCII table
SUB # We subtract that 'ASCII Offset' to get the real number
STORE 3 # We save the return value in the space reserved for it (offset is hard-coded)
STOREFP # We point FP to caller's AR
RET 0 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printB@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
BPRINT # We print the boolean we just loaded
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printIln@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
IPRINT # We print the integer we just loaded
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printI@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
IPRINT # We print the integer we just loaded
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Method_printBln@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
LOAD 3 # We put the parameter i at the top of the stack (offset is hard-coded)
BPRINT # We print the boolean we just loaded
PRNLN # We print the carriage return
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]

.CODE
Constructor@System: LOADFP # We store the dynamic link
LOADSP # We signal were the AR starts
STOREFP # We signal the AR being built as the current AR
STOREFP # We point FP to caller's AR
RET 1 # We free up memory cells equal to number of params [+1 if unit is dynamic]
